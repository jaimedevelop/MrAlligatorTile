# Firebase Database Documentation

This document outlines the schema, indexing strategies, and recommended practices for the Firebase Firestore database used by the Mr. Alligator Plumbing application.

## 1. Firestore Data Structure

The application utilizes several Firestore collections to store data. Each document within a collection has a unique ID automatically generated by Firestore or explicitly set. Timestamps are typically stored using Firestore's `Timestamp` type.

### 1.1 `projects` Collection

Stores details about completed plumbing projects.

```typescript
// Represents data structure in Firestore for a project document
interface Project {
  // Document ID is managed by Firestore
  title: string;
  category: 'Commercial' | 'Residential' | 'Emergency';
  description: string;
  image: string; // URL (e.g., from Firebase Storage)
  completionDate: firebase.firestore.Timestamp; // Use Firestore Timestamp
  highlights: string[];
  details: string;
  tableOnly?: boolean; // Flag for specific display modes
  specifications: {
    duration: string;
    location: string;
    services: string[];
    materials: string[];
  };
  projectDetails: {
    challenge: string;
    solution: string;
    outcome: string;
  };
  gallery: {
    url: string; // URL (e.g., from Firebase Storage)
    caption: string;
  }[];
  createdAt: firebase.firestore.Timestamp;
  updatedAt: firebase.firestore.Timestamp;
}
```

### 1.2 `appointments` Collection

Stores customer appointment requests and their status.

```typescript
// Represents data structure in Firestore for an appointment document
interface Appointment {
  // Document ID is managed by Firestore
  customerName: string;
  customerEmail: string;
  customerPhone: string;
  serviceType: ServiceType;
  preferredDate: firebase.firestore.Timestamp; // Use Firestore Timestamp
  alternativeDate?: firebase.firestore.Timestamp; // Optional
  description: string;
  status: AppointmentStatus;
  createdAt: firebase.firestore.Timestamp;
  updatedAt: firebase.firestore.Timestamp;
}

type ServiceType =
  | 'repair'
  | 'installation'
  | 'maintenance'
  | 'inspection'
  | 'emergency'
  | 'other';

type AppointmentStatus =
  | 'pending'
  | 'confirmed'
  | 'rejected'
  | 'completed'
  | 'cancelled';
```

### 1.3 `settings` Collection

Stores application settings, often using documents with fixed IDs (e.g., `appointmentSettings`, `seoSettings`).

#### 1.3.1 Appointment Settings (Document ID: `appointmentSettings`)

```typescript
// Represents data structure in Firestore for the appointment settings document
interface AppointmentSettings {
  // Document ID is 'appointmentSettings'
  enableScheduling: boolean;
  availableDays: number[]; // 0-6, where 0 is Sunday
  availableHours: {
    start: string; // Format: "HH:mm"
    end: string;   // Format: "HH:mm"
  };
  excludedDates: string[]; // ISO date strings (YYYY-MM-DD) or Timestamps
  maxDaysInAdvance: number;
  minDaysInAdvance: number;
  updatedAt: firebase.firestore.Timestamp;
}
```

#### 1.3.2 SEO Settings (Document ID: `seoSettings`)

```typescript
// Represents data structure in Firestore for the SEO settings document
interface SeoSettings {
  // Document ID is 'seoSettings'
  title: string;
  description: string;
  keywords: string[];
  updatedAt: firebase.firestore.Timestamp;
}
```

### 1.4 `pages` Collection

Stores content for dynamically managed pages.

```typescript
// Represents data structure in Firestore for a page content document
interface PageContent {
  // Document ID is managed by Firestore (e.g., 'home', 'about')
  title: string;
  content: string; // HTML or Markdown content
  pageType: PageType; // Differentiates standard pages from cards, etc.
  seo: PageSeo; // Embedded SEO map/object
  createdAt: firebase.firestore.Timestamp;
  updatedAt: firebase.firestore.Timestamp;
}

type PageType = 'page' | 'card';

// Represents the embedded SEO object within a PageContent document
interface PageSeo {
  title: string;
  description: string;
  keywords: string[];
  canonicalUrl: string;
  redirectUrl: string;
  robots: {
    noindex: boolean;
    nofollow: boolean;
    noarchive: boolean;
    nosnippet: boolean;
    noimageindex: boolean;
    notranslate: boolean;
  };
  schema: string; // JSON-LD schema string
  social: {
    ogTitle: string;
    ogDescription: string;
    ogImage: string;
    twitterCard: 'summary' | 'summary_large_image' | 'app' | 'player';
    twitterTitle: string;
    twitterDescription: string;
    twitterImage: string;
  };
}
```

## 2. Firestore Indexing

Firestore automatically creates single-field indexes for all document fields. For more complex queries involving multiple fields (e.g., filtering by `category` and sorting by `completionDate`), **composite indexes** must be created manually in the Firebase Console.

- **Automatic Indexes:** Support basic equality (`==`) and range (`<`, `>`, `<=`, `>=`) queries on single fields, and sorting on a single field.
- **Composite Indexes:** Required for:
    - Queries with range filters on multiple fields.
    - Queries with equality (`==`) or `in` clauses combined with sorting on a different field.
    - Queries involving `orderBy()` on multiple fields.

When a query requires a composite index that doesn't exist, the Firebase SDK will often provide an error message in the console containing a direct link to create the necessary index in the Firebase Console.

**Example Composite Index Needs:**

-   **Projects:** Querying by `category` (equality) and sorting by `completionDate` (descending) requires a composite index on (`category` ASC, `completionDate` DESC).
-   **Appointments:** Querying by `status` (equality) and sorting by `preferredDate` (ascending) requires a composite index on (`status` ASC, `preferredDate` ASC).

Refer to the Firebase Firestore documentation for detailed indexing best practices.

## 3. Querying Data (Firebase SDK Examples)

Data fetching is handled by the service files (`src/services/*.ts`) using the Firebase Web SDK (v9 modular API recommended).

### 3.1 Fetching Projects (`projectsService.ts`)

```typescript
import { collection, query, where, orderBy, getDocs, doc, getDoc } from 'firebase/firestore';
import { db } from '../utils/firebase/database'; // Assuming db export from firebase setup

const projectsCollection = collection(db, 'projects');

// Efficient project listing by category
const getProjectsByCategory = async (category: string) => {
  const q = query(
    projectsCollection,
    where('category', '==', category),
    orderBy('completionDate', 'desc') // Requires composite index
  );
  const querySnapshot = await getDocs(q);
  return querySnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
};

// Get projects for table display
const getDisplayProjects = async (tableOnly: boolean = false) => {
  const q = query(
    projectsCollection,
    where('tableOnly', '==', tableOnly)
    // Add orderBy if needed, potentially requiring another index
  );
  const querySnapshot = await getDocs(q);
  return querySnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
};

// Get single project by ID
const getProjectById = async (id: string) => {
  const docRef = doc(db, 'projects', id);
  const docSnap = await getDoc(docRef);
  return docSnap.exists() ? { id: docSnap.id, ...docSnap.data() } : null;
};
```

### 3.2 Appointment Management (`appointmentsService.ts`)

```typescript
import { collection, query, where, orderBy, getDocs, Timestamp } from 'firebase/firestore';
import { db } from '../utils/firebase/database';

const appointmentsCollection = collection(db, 'appointments');

// Get appointments by status
const getAppointmentsByStatus = async (status: AppointmentStatus) => {
  const q = query(
    appointmentsCollection,
    where('status', '==', status),
    orderBy('preferredDate', 'asc') // Requires composite index
  );
  const querySnapshot = await getDocs(q);
  return querySnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
};

// Get appointments by date range
const getAppointmentsByDate = async (startDate: Date, endDate: Date) => {
  const startTimestamp = Timestamp.fromDate(startDate);
  const endTimestamp = Timestamp.fromDate(endDate);

  const q = query(
    appointmentsCollection,
    where('preferredDate', '>=', startTimestamp),
    where('preferredDate', '<=', endTimestamp),
    orderBy('preferredDate', 'asc') // Requires composite index if combined with other filters/orders
  );
  const querySnapshot = await getDocs(q);
  return querySnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
};
```

### 3.3 Page Management (`pagesService.ts`)

```typescript
import { collection, query, where, getDocs } from 'firebase/firestore';
import { db } from '../utils/firebase/database';

const pagesCollection = collection(db, 'pages');

// Get pages by type
const getPagesByType = async (pageType: PageType) => {
  const q = query(pagesCollection, where('pageType', '==', pageType));
  const querySnapshot = await getDocs(q);
  return querySnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
};

// Search pages by SEO title (Basic equality, consider Algolia/Typesense for full-text search)
const searchPagesByTitle = async (titleQuery: string) => {
  // Firestore doesn't support case-insensitive or partial string matches efficiently.
  // This performs an exact match (case-sensitive).
  const q = query(pagesCollection, where('seo.title', '==', titleQuery));
  const querySnapshot = await getDocs(q);
  return querySnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));

  // For better search, integrate a dedicated search service.
};
```

## 4. Real-time Updates & Offline Persistence

Firebase Firestore provides real-time data synchronization and optional offline data persistence.

### 4.1 Real-time Listeners (`onSnapshot`)

Instead of fetching data once with `getDocs`, you can set up real-time listeners using `onSnapshot`. This automatically pushes updates to the client whenever data changes in the specified collection or document.

```typescript
import { collection, query, where, onSnapshot } from 'firebase/firestore';
import { db } from '../utils/firebase/database';

// Example: Listening for pending appointments
const listenForPendingAppointments = (callback: (appointments: any[]) => void) => {
  const q = query(collection(db, 'appointments'), where('status', '==', 'pending'));

  const unsubscribe = onSnapshot(q, (querySnapshot) => {
    const appointments = querySnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
    callback(appointments); // Pass updated data to the application state
  }, (error) => {
    console.error("Error listening to appointments:", error);
    // Handle error appropriately
  });

  return unsubscribe; // Return the function to stop listening later
};
```
*(This pattern can be applied in services or hooks to keep UI state synchronized)*

### 4.2 Offline Persistence

The Firebase Web SDK can cache data locally, allowing the application to function offline and sync changes when connectivity is restored.

- **Enable Persistence:** Call `enablePersistence()` when initializing Firestore.
- **Behavior:** Reads will first hit the cache, providing instant data access while checking the server for updates in the background (if online). Writes are queued locally and sent to the server when online.

```typescript
// In firebase initialization (e.g., utils/firebase/database.js or index.js)
import { initializeFirestore, enableIndexedDbPersistence } from 'firebase/firestore';
import { app } from './config'; // Your Firebase app config

const db = initializeFirestore(app, {
  // Optional: Configure cache size if needed
  // cacheSizeBytes: CACHE_SIZE_UNLIMITED
});

enableIndexedDbPersistence(db)
  .then(() => {
    console.log("Offline persistence enabled");
  })
  .catch((err) => {
    if (err.code == 'failed-precondition') {
      // Multiple tabs open, persistence can only be enabled in one.
      console.warn("Persistence failed: Multiple tabs open?");
    } else if (err.code == 'unimplemented') {
      // The current browser does not support all of the
      // features required to enable persistence
      console.error("Persistence failed: Browser not supported.");
    } else {
       console.error("Persistence failed:", err);
    }
  });

export { db };
```

## 5. Performance Monitoring

- **Firebase Performance Monitoring:** Integrates with the Firebase SDK to automatically monitor network request times and allows custom traces to measure application-specific code performance.
- **Firestore Console:** Provides insights into read/write operations, index usage, and potential hotspots. Check the "Usage" and "Indexes" tabs.
- **Browser DevTools:** Use the Network tab to inspect Firestore requests and the Console for SDK logs/errors.

## 6. Security Protocols

Security is primarily managed through Firebase Authentication and Firestore Security Rules.

### 6.1 Firebase Authentication

- Handles user sign-up, sign-in, password resets, and session management.
- Configured in `src/utils/firebase/auth.js` and likely used within authentication hooks or components.
- Supports various providers (Email/Password, Google, etc.).

### 6.2 Firestore Security Rules

- Define access control logic directly within the Firebase Console.
- Rules are evaluated server-side to determine if a read or write operation is allowed based on user authentication status, user roles (often stored as custom claims or in a user profile document), and the data being accessed/modified.
- **Crucial** for protecting data from unauthorized access.

**Example Security Rules Snippet:**

```js
// In Firebase Console -> Firestore Database -> Rules
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // Allow public read access to projects
    match /projects/{projectId} {
      allow read: if true;
      // Allow write only if user is authenticated and has 'admin' custom claim
      allow write: if request.auth != null && request.auth.token.admin == true;
    }

    // Allow users to read/write their own appointments, admins can read/write all
    match /appointments/{appointmentId} {
      allow read, write: if request.auth != null && (request.auth.uid == resource.data.userId || request.auth.token.admin == true);
      // Allow creation if authenticated
      allow create: if request.auth != null;
    }

    // Allow read access to settings for everyone
    match /settings/{settingId} {
       allow read: if true;
       // Allow write only for admins
       allow write: if request.auth != null && request.auth.token.admin == true;
    }

     // Allow read access to pages for everyone
    match /pages/{pageId} {
       allow read: if true;
       // Allow write only for admins
       allow write: if request.auth != null && request.auth.token.admin == true;
    }

    // Add rules for other collections...
  }
}
```
*(These are illustrative examples; actual rules must be carefully crafted based on specific application requirements.)*

### 6.3 Admin Operations

Admin operations are protected by:

1.  **Frontend:** Client-side route guards and UI checks ensure the user is authenticated and has the necessary role/claim (e.g., `admin: true` in their auth token) before allowing access to admin sections or triggering admin actions.
2.  **Backend (Firestore Security Rules):** Server-side rules enforce that only authenticated users with the 'admin' role/claim can perform write operations (create, update, delete) on protected collections like `projects`, `settings`, `pages`, or modify appointments belonging to other users.

## 7. Data Migration

- The project involved a data migration **to** Firebase Firestore from a previous database system (CouchDB).
- Ensure data integrity was maintained during the transfer. Any scripts used for migration should be documented or removed if no longer needed.
- Old database-related code specific to CouchDB/PouchDB should be removed.